/**
 * JSON Repair Utility
 *
 * Attempts to fix common JSON syntax errors generated by LLMs
 */

export interface RepairResult {
  success: boolean;
  data?: any;
  error?: string;
  repairApplied?: string;
}

/**
 * Comprehensive JSON repair function
 * Attempts multiple repair strategies in sequence
 */
export function repairJSON(jsonString: string): RepairResult {
  // Pre-check: Detect obviously truncated JSON
  const trimmed = jsonString.trim();
  const truncatedPattern = /"([^"]+)":\s*$/;
  if (truncatedPattern.test(trimmed)) {
    const match = trimmed.match(truncatedPattern);
    return {
      success: false,
      error: `JSON appears truncated. Last field "${match?.[1]}" has no value. The AI response may have hit token limits.`
    };
  }

  // Strategy 1: Try parsing as-is
  try {
    const data = JSON.parse(jsonString);
    return { success: true, data };
  } catch (error) {
    // Continue to repair strategies
  }

  // Strategy 2: Fix trailing commas
  try {
    let repaired = jsonString
      .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas before } or ]

    const data = JSON.parse(repaired);
    return { success: true, data, repairApplied: 'trailing_commas' };
  } catch (error) {
    // Continue
  }

  // Strategy 3: Fix unquoted keys and single quotes
  try {
    let repaired = jsonString
      // First, fix trailing commas
      .replace(/,(\s*[}\]])/g, '$1')
      // Replace single quotes with double quotes (be careful with apostrophes in values)
      .replace(/'([^']*?)'/g, (match, p1) => {
        // If it looks like a key (followed by :), replace quotes
        if (jsonString.indexOf(match + ':') !== -1 || jsonString.indexOf(match + ' :') !== -1) {
          return `"${p1}"`;
        }
        // If it's a value, also replace
        return `"${p1}"`;
      })
      // Fix unquoted keys (word characters followed by colon)
      .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
      // Fix keys that might have spaces or hyphens
      .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_\s-]*?)\s*:/g, (match, prefix, key) => {
        // Only quote if not already quoted
        if (!key.startsWith('"')) {
          return `${prefix}"${key.trim()}":`;
        }
        return match;
      });

    const data = JSON.parse(repaired);
    return { success: true, data, repairApplied: 'quotes_and_keys' };
  } catch (error) {
    // Continue
  }

  // Strategy 4: Remove comments (sometimes AI adds them)
  try {
    let repaired = jsonString
      // Remove single-line comments
      .replace(/\/\/.*$/gm, '')
      // Remove multi-line comments
      .replace(/\/\*[\s\S]*?\*\//g, '')
      // Fix trailing commas
      .replace(/,(\s*[}\]])/g, '$1')
      // Fix quotes
      .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');

    const data = JSON.parse(repaired);
    return { success: true, data, repairApplied: 'comments_removed' };
  } catch (error) {
    // Continue
  }

  // Strategy 5: Fix common escape issues
  try {
    let repaired = jsonString
      // Fix unescaped quotes in strings
      .replace(/"([^"]*?)"([^"]*?)"/g, (match, p1, p2) => {
        if (p2.includes(':') || p2.includes(',')) {
          // Likely end of value
          return `"${p1.replace(/"/g, '\\"')}"${p2}`;
        }
        return match;
      })
      // Fix trailing commas
      .replace(/,(\s*[}\]])/g, '$1')
      // Fix unquoted keys
      .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');

    const data = JSON.parse(repaired);
    return { success: true, data, repairApplied: 'escape_fixes' };
  } catch (error) {
    // Continue
  }

  // Strategy 6: Try to extract valid JSON from potentially malformed text
  try {
    // Look for the outermost { } or [ ]
    const jsonMatch = jsonString.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
    if (jsonMatch) {
      let repaired = jsonMatch[0]
        .replace(/,(\s*[}\]])/g, '$1')
        .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
        .replace(/'([^']*?)'/g, '"$1"');

      const data = JSON.parse(repaired);
      return { success: true, data, repairApplied: 'extraction_and_repair' };
    }
  } catch (error) {
    // Continue
  }

  // Strategy 7: Aggressive repair - reconstruct JSON
  try {
    let repaired = jsonString
      // Normalize whitespace
      .replace(/\s+/g, ' ')
      // Fix all single quotes to double quotes
      .replace(/'/g, '"')
      // Remove trailing commas
      .replace(/,(\s*[}\]])/g, '$1')
      // Ensure all keys are quoted
      .replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":')
      // Fix missing commas between properties (heuristic)
      .replace(/"(\s*)"([a-zA-Z_])/g, '","$2');

    const data = JSON.parse(repaired);
    return { success: true, data, repairApplied: 'aggressive_reconstruction' };
  } catch (error) {
    // All strategies failed
  }

  // All repair strategies failed
  return {
    success: false,
    error: 'All JSON repair strategies failed. The JSON is too malformed to auto-fix.'
  };
}

/**
 * Validate if a string is valid JSON
 */
export function isValidJSON(str: string): boolean {
  try {
    JSON.parse(str);
    return true;
  } catch {
    return false;
  }
}

/**
 * Pretty print JSON for debugging
 */
export function prettyPrintJSON(obj: any): string {
  return JSON.stringify(obj, null, 2);
}

/**
 * Extract JSON from text that might have markdown or other formatting
 */
export function extractJSON(text: string): string | null {
  // Try to find JSON in code blocks
  const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]+?)\s*```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1];
  }

  // Try to find raw JSON object
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }

  // Try to find JSON array
  const arrayMatch = text.match(/\[[\s\S]*\]/);
  if (arrayMatch) {
    return arrayMatch[0];
  }

  return null;
}
